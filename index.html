<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sandmotion | Enterprise Suite</title>
    
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    
    <style>
        /* --- CORE SETTINGS --- */
        body { margin: 0; overflow: hidden; font-family: 'Montserrat', sans-serif; background: #080808; cursor: default; user-select: none; -webkit-tap-highlight-color: transparent; height: 100dvh; width: 100vw; }
        #renderCanvas { width: 100%; height: 100dvh; touch-action: none; outline: none; }
        
        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; transition: opacity 0.5s; }
        .interactive { pointer-events: auto; }
        #debug-box { display: none; }

        /* --- UI ELEMENTS --- */
        #brand-box { position: absolute; top: 25px; left: 30px; display: flex; flex-direction: column; z-index: 20; text-shadow: 0 4px 12px rgba(0,0,0,0.8); }
        .project-title { color: white; font-weight: 300; font-size: 24px; letter-spacing: 4px; text-transform: uppercase; margin: 0; }
        .brand-sub { color: #00E5FF; font-size: 10px; font-weight: 700; letter-spacing: 3px; text-transform: uppercase; margin-top: 4px; opacity: 0.9; display: block; }

        /* SUN CONTROLS */
        #sun-container { 
            position: absolute; top: 30px; right: 30px; 
            pointer-events: auto; z-index: 100; 
            display: flex; flex-direction: column; align-items: flex-end; gap: 5px; 
        }
        .sun-label { color: #00E5FF; font-size: 9px; font-weight: 800; letter-spacing: 1px; text-transform: uppercase; text-shadow: 0 2px 4px rgba(0,0,0,0.8); margin-right: 5px; display: block; }
        #sun-slider-box { background: rgba(0,0,0,0.6); padding: 8px 12px; border-radius: 20px; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.2); display: flex; align-items: center; }
        input[type=range] { width: 120px; height: 15px; -webkit-appearance: none; appearance: none; background: transparent; outline: none; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -6px; width: 16px; height: 16px; background: #00E5FF; border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px rgba(0,229,255,0.5); border: 2px solid white; }

        #cam-btn { position: absolute; top: 100px; right: 30px; width: 45px; height: 45px; border-radius: 50%; background: rgba(255,255,255,0.1); color: white; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1); transition: 0.2s; z-index: 100; font-size: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        #cam-btn:hover { background: white; color: black; transform: scale(1.1); }
        #whatsapp-btn { position: absolute; bottom: 120px; right: 30px; width: 55px; height: 55px; border-radius: 50%; background: #25D366; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; z-index: 100; font-size: 28px; color: white; text-decoration: none; box-shadow: 0 10px 25px rgba(37,211,102,0.4); transition: transform 0.2s; }
        #whatsapp-btn:hover { transform: scale(1.1); }

        /* CONTROL BAR */
        #controls-bar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; padding: 10px 25px; background: rgba(10, 10, 10, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 50px; box-shadow: 0 20px 40px rgba(0,0,0,0.5); z-index: 50; transition: all 0.4s ease; }
        #controls-bar.light-mode { background: rgba(255, 255, 255, 0.9); border-color: #ccc; box-shadow: 0 10px 30px rgba(0,0,0,0.15); }
        .ctrl-btn { width: 48px; height: 48px; border-radius: 50%; background: rgba(255, 255, 255, 0.05); color: rgba(255, 255, 255, 0.6); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: 700; transition: all 0.2s; position: relative; border: 1px solid transparent; }
        #controls-bar.light-mode .ctrl-btn { color: #444; background: rgba(0,0,0,0.05); }
        .ctrl-btn:hover { background: rgba(255, 255, 255, 0.15); color: white; transform: translateY(-3px); }
        .ctrl-btn.active { background: #00E5FF !important; color: black !important; box-shadow: 0 0 20px rgba(0, 229, 255, 0.4); transform: scale(1.05); border-color: #00E5FF; }
        .tooltip { position: absolute; bottom: 65px; left: 50%; transform: translateX(-50%); background: #000; color: white; padding: 5px 10px; border-radius: 4px; font-size: 10px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; opacity: 0; pointer-events: none; transition: 0.2s; white-space: nowrap; pointer-events: none; }
        .ctrl-btn:hover .tooltip { opacity: 1; bottom: 60px; }

        /* MODALS */
        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #050505; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; transition: opacity 0.5s; }
        #lead-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); backdrop-filter: blur(15px); z-index: 100; justify-content: center; align-items: center; }
        .modal-box { background: rgba(30, 30, 30, 0.8); border: 1px solid rgba(255, 255, 255, 0.1); color: white; padding: 40px 30px; border-radius: 20px; width: 90%; max-width: 350px; text-align: center; }
        .input-field { width: 100%; padding: 15px; margin-bottom: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: white; border-radius: 10px; font-size: 14px; outline: none; box-sizing: border-box; }
        .unlock-btn { background: linear-gradient(135deg, #00E5FF 0%, #0088AA 100%); border: none; padding: 15px 0; width: 100%; font-weight: 700; font-size: 13px; cursor: pointer; border-radius: 10px; color: #000; letter-spacing: 1px; margin-top: 10px; text-transform: uppercase; }
        .skip-btn { margin-top: 20px; font-size: 11px; color: #666; cursor: pointer; text-decoration: underline; }
        
        #hover-tooltip { position: absolute; display: none; background: rgba(0, 0, 0, 0.9); border-left: 3px solid #00E5FF; color: white; padding: 8px 12px; border-radius: 0 6px 6px 0; font-size: 11px; font-weight: 700; letter-spacing: 1px; pointer-events: none; z-index: 50; }
        #tour-status { display: none; position: absolute; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(220, 20, 60, 0.9); color: white; padding: 6px 16px; border-radius: 20px; font-size: 11px; font-weight: 800; letter-spacing: 1px; pointer-events: none; box-shadow: 0 0 20px rgba(220, 20, 60, 0.6); animation: pulse 2s infinite; z-index: 25; }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; } 100% { opacity: 0.8; } }
        #crosshair { display: none; position: absolute; top: 50%; left: 50%; width: 8px; height: 8px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 40; border: 1px solid black; }
        #walk-instruct { position: absolute; top: 80%; left: 50%; transform: translate(-50%); color: white; background: rgba(0,0,0,0.5); padding: 6px 12px; border-radius: 20px; font-size: 10px; pointer-events: none; transition: opacity 1s; opacity: 0; z-index: 40; font-weight: 600; letter-spacing: 1px; }
        #info-card { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; color: black; padding: 30px; width: 300px; text-align: left; z-index: 60; box-shadow: 0 30px 60px rgba(0,0,0,0.3); border-radius: 8px; }
        .close-info { margin-top: 20px; font-size: 11px; cursor: pointer; text-decoration: underline; color: #999; text-transform: uppercase; letter-spacing: 1px; }

        /* --- MOBILE RESPONSIVE FIXES --- */
        @media (max-width: 768px) {
            #brand-box { top: 20px; left: 20px; }
            .project-title { font-size: 18px; letter-spacing: 2px; }
            .brand-sub { display: none; } 
            #sun-container { top: 20px; right: 70px; gap: 0; } 
            .sun-label { display: none; } 
            #sun-slider-box { padding: 5px 10px; }
            input[type=range] { width: 80px; } 
            #cam-btn { top: 20px; right: 20px; width: 40px; height: 40px; }
            #controls-bar { width: 85%; padding: 10px 15px; bottom: 20px; justify-content: space-between; gap: 5px; }
            .ctrl-btn { width: 42px; height: 42px; font-size: 14px; }
            #whatsapp-btn { bottom: 90px; right: 20px; width: 50px; height: 50px; font-size: 24px; }
            #tour-status { top: 80px; }
        }
    </style>
</head>
<body>
    <div id="loader"><div style="color:white; font-size:24px; letter-spacing:5px;">SANDMOTION</div></div>
    <div id="lead-modal" class="interactive">
        <div class="modal-box">
            <div style="font-size:18px; font-weight:700;">VIP ACCESS</div>
            <div style="font-size:12px; color:#aaa; margin-bottom:20px;">Unlock walkthrough.</div>
            <input type="text" id="lead-name" class="input-field" placeholder="Name">
            <input type="tel" id="lead-phone" class="input-field" placeholder="Mobile">
            <button class="unlock-btn" onclick="submitLead()">UNLOCK</button>
            <div class="skip-btn" onclick="closeModal()">Skip</div>
        </div>
    </div>

    <div id="ui-layer">
        <div id="brand-box"><div class="project-title">SANDMOTION</div><div class="brand-sub">LUXURY RESIDENCES</div></div>
        
        <div id="sun-container" class="interactive">
            <div class="sun-label">SUN ROTATION</div>
            <div id="sun-slider-box"><input type="range" id="time-slider" min="0" max="100" value="50"></div>
        </div>
        
        <div id="controls-bar" class="interactive">
            <div class="ctrl-btn active" id="btn-orbit" onclick="setMode('orbit')">3D<span class="tooltip">ORBIT</span></div>
            <div class="ctrl-btn" id="btn-tour" onclick="toggleTour()">‚ñ∂<span class="tooltip">TOUR</span></div>
            <div class="ctrl-btn" id="btn-walk" onclick="setMode('walk')">üö∂<span class="tooltip">WALK</span></div>
            <div class="ctrl-btn" id="btn-blue" onclick="toggleBlueprint()">2D<span class="tooltip">2D PLAN</span></div>
            <div class="ctrl-btn" id="btn-furn" onclick="toggleFurniture()">üõãÔ∏è<span class="tooltip">FURNITURE</span></div>
        </div>
    </div>

    <div id="cam-btn" onclick="takeScreenshot()">üì∑</div>
    <a id="whatsapp-btn" href="https://wa.me/918208072906" target="_blank">üí¨</a>
    <div id="tour-status">üî¥ LIVE TOUR</div>
    <div id="hover-tooltip">ROOM</div>
    <div id="crosshair"></div>
    <div id="walk-instruct">TAP CIRCLES TO MOVE</div>
    <div id="info-card" class="interactive">
        <div id="info-title">FEATURE</div>
        <div id="info-desc">Desc</div>
        <div class="close-info" onclick="document.getElementById('info-card').style.display='none'">CLOSE</div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
    window.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, antialias: true });
        const dpr = window.devicePixelRatio || 1;
        engine.setHardwareScalingLevel(1 / dpr); 

        let sceneRef, orbitCam, walkCam, topCam, sunLight, shadowGen, hl;
        let advancedTexture, labels = [], navPucks = [], infoSpots = [];
        let currentMode = 'orbit';
        let blueprintMode = false;
        let furnitureVisible = true;
        let isTouring = false;
        let tourIndex = 0;
        let tourWaypoints = [];
        
        const isMobile = window.innerWidth < 768;
        let currentOrthoScale = 1.0; 
        
        // Movement Vars
        let isMoving = false; let moveStartTime = 0; let moveDuration = 0;
        let startPos = null; let targetPos = null; let startTarget = null; let endTarget = null; 
        
        const createScene = function () {
            const scene = new BABYLON.Scene(engine);
            
            // --- 1. PREMIUM STUDIO ENVIRONMENT ---
            scene.clearColor = new BABYLON.Color4(0.03, 0.03, 0.04, 1); // Deep, rich cinematic dark
            
            // IBL is the PRIMARY Light Source
            const envTexture = BABYLON.CubeTexture.CreateFromPrefilteredData("https://assets.babylonjs.com/environments/environmentSpecular.env", scene);
            scene.environmentTexture = envTexture;
            scene.environmentIntensity = 1.0; // Balanced Natural Look

            hl = new BABYLON.HighlightLayer("hl1", scene);
            hl.innerGlow = false; hl.outerGlow = true;

            // --- 2. SUN LIGHT (For Shadows & Definition) ---
            sunLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -2, -1), scene);
            sunLight.position = new BABYLON.Vector3(20, 40, 20);
            sunLight.intensity = 1.2; // Strong enough to cast crisp shadows, but not wash out texture
            
            shadowGen = new BABYLON.ShadowGenerator(2048, sunLight);
            shadowGen.usePercentageCloserFiltering = true; 
            shadowGen.transparencyShadow = true;

            orbitCam = new BABYLON.ArcRotateCamera("OrbitCam", -Math.PI/2, Math.PI/3, 15, new BABYLON.Vector3(0, 0, 0), scene);
            orbitCam.lowerRadiusLimit = 2; orbitCam.upperRadiusLimit = 100; orbitCam.minZ = 0.45;
            orbitCam.attachControl(canvas, true);
            orbitCam.useAutoRotationBehavior = true;

            walkCam = new BABYLON.UniversalCamera("WalkCam", new BABYLON.Vector3(0, 1.2, 0), scene);
            walkCam.minZ = 0.45; walkCam.speed = 0.2; walkCam.checkCollisions = true; walkCam.applyGravity = true; walkCam.ellipsoid = new BABYLON.Vector3(0.4, 0.8, 0.4);
            walkCam.keysUp = [87]; walkCam.keysDown = [83]; walkCam.keysLeft = [65]; walkCam.keysRight = [68]; 
            
            topCam = new BABYLON.FreeCamera("TopCam", new BABYLON.Vector3(0, 50, 0), scene);
            topCam.setTarget(BABYLON.Vector3.Zero());
            topCam.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
            updateOrtho();
            
            scene.activeCamera = orbitCam;

            advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            advancedTexture.renderScale = 2.0; 

            // --- 3. CINEMATIC COLOR GRADING (ACES) ---
            const pipeline = new BABYLON.DefaultRenderingPipeline("default", true, scene, [orbitCam, walkCam, topCam]);
            pipeline.samples = 4; 
            pipeline.fxaaEnabled = true; 
            
            // Subtle Bloom (Expensive Look)
            pipeline.bloomEnabled = true; 
            pipeline.bloomThreshold = 0.95; // Only hits the brightest highlights
            pipeline.bloomWeight = 0.15; // Very soft glow
            pipeline.bloomKernel = 64; 
            
            // Tone Mapping = Realism
            pipeline.imageProcessing.toneMappingEnabled = true;
            pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
            pipeline.imageProcessing.exposure = 0.8; // Slightly lowered to prevent washout
            pipeline.imageProcessing.contrast = 1.1; // High contrast for depth

            if (BABYLON.SSAO2RenderingPipeline.IsSupported) {
                const ssao = new BABYLON.SSAO2RenderingPipeline("ssao", scene, 0.75, [topCam]);
                ssao.radius = 6.0; ssao.totalStrength = 0.8; ssao.base = 0.4;
                scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline("ssao", [orbitCam, walkCam, topCam]);
            }

            BABYLON.SceneLoader.Append("./", "model.glb", scene, function (scene) {
                document.getElementById("loader").style.display = "none";
                setTimeout(()=>{document.getElementById("lead-modal").style.display="flex"}, 100);

                const allNodes = scene.transformNodes.concat(scene.meshes);
                allNodes.forEach(node => {
                    const lowerName = node.name.toLowerCase();
                    if (lowerName.includes("start_point")) { 
                        orbitCam.setTarget(node.position); 
                        walkCam.position = new BABYLON.Vector3(node.position.x, 1.2, node.position.z);
                    }
                    if (lowerName.includes("nav_")) {
                        const abs = node.getAbsolutePosition();
                        createTeleportPuck(abs, abs); 
                        tourWaypoints.push({ name: node.name, pos: abs });
                        node.isVisible = false; 
                    }
                    if (lowerName.includes("label_")) { createRoomLabel(node); node.isVisible = false; }
                    if (lowerName.includes("info_")) { createInfoSpot(node.position, node.name); node.isVisible = false; }
                    if (node instanceof BABYLON.Mesh) {
                        node.checkCollisions = true; node.receiveShadows = true; shadowGen.addShadowCaster(node);
                        if(node.material) {
                            if (lowerName.includes("floor") || lowerName.includes("wall")) { node.material.roughness = 0.9; node.material.metallic = 0.0; }
                            if(lowerName.includes("glass")) { node.material.alpha = 0.2; shadowGen.removeShadowCaster(node); }
                        }
                    }
                });
                
                tourWaypoints.sort((a, b) => a.name.localeCompare(b.name));
                navPucks.forEach(p => p.setEnabled(true));
            });

            scene.onPointerObservable.add((pi) => {
                if (pi.type === BABYLON.PointerEventTypes.POINTERWHEEL && blueprintMode) {
                    const delta = pi.event.deltaY > 0 ? 1.1 : 0.9; 
                    currentOrthoScale *= delta;
                    if(currentOrthoScale < 0.2) currentOrthoScale = 0.2; 
                    if(currentOrthoScale > 10.0) currentOrthoScale = 10.0; 
                    updateOrtho();
                }
            });

            scene.onBeforeRenderObservable.add(() => {
                if (isMoving && walkCam) {
                    const now = Date.now();
                    const progress = Math.min(1, (now - moveStartTime) / moveDuration);
                    const ease = 1 - Math.pow(1 - progress, 3);
                    
                    walkCam.position = BABYLON.Vector3.Lerp(startPos, targetPos, ease);
                    const currentTarget = BABYLON.Vector3.Lerp(startTarget, endTarget, ease);
                    walkCam.setTarget(currentTarget);

                    if (progress >= 1) isMoving = false;
                }
                
                if (isTouring && !isMoving && !blueprintMode) {
                    walkCam.cameraRotation.y += 0.0002; 
                }
            });

            sceneRef = scene;
            return scene;
        };

        function updateOrtho() {
            if(!topCam) return;
            const ratio = engine.getAspectRatio(topCam);
            const targetSize = 40; 
            let orthoSize = 22;

            if (ratio < 1) { orthoSize = (targetSize / 2) / ratio; }
            else { orthoSize = 22; }

            orthoSize *= currentOrthoScale;

            topCam.orthoTop = orthoSize; 
            topCam.orthoBottom = -orthoSize; 
            topCam.orthoLeft = -orthoSize * ratio; 
            topCam.orthoRight = orthoSize * ratio;
        }

        window.toggleBlueprint = function() {
            blueprintMode = !blueprintMode;
            document.getElementById("btn-blue").classList.toggle("active");
            const bar = document.getElementById("controls-bar");
            const title = document.querySelector(".project-title");

            if (blueprintMode) {
                currentOrthoScale = 1.0; 
                sceneRef.activeCamera.detachControl(); updateOrtho(); sceneRef.activeCamera = topCam;
                
                // 2D MODE: BRIGHT & CLEAN
                if(sunLight) sunLight.intensity = 0.0;
                sceneRef.clearColor = new BABYLON.Color4(1,1,1,1); // Pure White
                // Temporarily boost reflection for visibility
                scene.environmentIntensity = 2.0; 
                
                labels.forEach(l => l.isVisible = true);
                navPucks.forEach(p => p.setEnabled(false));
                
                sceneRef.meshes.forEach(m => {
                    const lower = m.name.toLowerCase();
                    if(lower.includes("roof") || lower.includes("ceil")) m.setEnabled(false);
                    if(lower.includes("floor")) m.receiveShadows = false;
                });
                bar.classList.add("light-mode"); title.style.color = "black";
            } else {
                sceneRef.activeCamera.detachControl(); sceneRef.activeCamera = orbitCam; orbitCam.attachControl(canvas, true);
                
                // 3D MODE: CINEMATIC DARK
                if(sunLight) sunLight.intensity = 1.2;
                sceneRef.clearColor = new BABYLON.Color4(0.03, 0.03, 0.04, 1);
                scene.environmentIntensity = 1.0; 
                
                labels.forEach(l => l.isVisible = false);
                navPucks.forEach(p => p.setEnabled(true));
                
                sceneRef.meshes.forEach(m => {
                    m.setEnabled(true);
                    if(m.name.toLowerCase().includes("floor")) m.receiveShadows = true;
                    if(m.name.toLowerCase().includes("furniture") && !furnitureVisible) m.setEnabled(false);
                });
                bar.classList.remove("light-mode"); title.style.color = "white";
            }
        };

        window.toggleFurniture = function() {
            furnitureVisible = !furnitureVisible;
            document.getElementById("btn-furn").classList.toggle("active");
            sceneRef.meshes.forEach(m => {
                const lower = m.name.toLowerCase();
                if(lower.includes("furniture") || m.metadata === "furniture" || lower.includes("sofa") || lower.includes("bed") || lower.includes("table") || lower.includes("chair")) {
                    m.setEnabled(furnitureVisible);
                }
            });
        };

        window.setMode = function(m){ 
            if(m==='walk' && !localStorage.getItem("sandmotion_unlocked")) {
                document.getElementById("lead-modal").style.display="flex"; return;
            }
            if(isTouring) stopTour(); 
            currentMode=m;
            document.querySelectorAll('.ctrl-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + m).classList.add('active');
            if(furnitureVisible) document.getElementById('btn-furn').classList.add('active');

            if(m==='walk'){ 
                sceneRef.activeCamera.detachControl(); 
                sceneRef.activeCamera=walkCam; 
                walkCam.attachControl(canvas,true); 
                document.getElementById('crosshair').style.display='block';
            } else { 
                sceneRef.activeCamera.detachControl(); 
                sceneRef.activeCamera=orbitCam; 
                orbitCam.attachControl(canvas,true); 
                document.getElementById('crosshair').style.display='none';
            } 
            if(blueprintMode) toggleBlueprint(); 
        };

        window.toggleTour = function(){ 
            if(isTouring) {
                stopTour();
            } else { 
                startTour(); 
            } 
        };
        
        window.stopTour = function() {
            isTouring = false; 
            isMoving = false;
            document.getElementById('btn-tour').classList.remove('active');
            document.getElementById('tour-status').style.display='none';
            document.getElementById('brand-box').style.opacity = '1';
            document.getElementById('sun-container').style.opacity = '1';
        };
        
        window.startTour = function() {
            if(blueprintMode) toggleBlueprint(); 
            window.setMode('walk'); 
            isTouring = true; 
            document.getElementById('btn-tour').classList.add('active');
            document.getElementById('tour-status').style.display='block';
            document.getElementById('brand-box').style.opacity = '0';
            document.getElementById('sun-container').style.opacity = '0';

            if(tourWaypoints.length > 0) {
                navPucks.forEach(p => p.setEnabled(true));
                
                let idx = tourWaypoints.findIndex(wp => wp.name.toLowerCase().includes("nav_01"));
                if (idx === -1) idx = 0; 

                walkCam.position = new BABYLON.Vector3(tourWaypoints[idx].pos.x, 1.2, tourWaypoints[idx].pos.z);

                function playNextLeg() {
                    if(!isTouring) return;
                    
                    const pt = tourWaypoints[idx];
                    const nextIdx = (idx + 1) % tourWaypoints.length;
                    const nextPt = tourWaypoints[nextIdx];
                    
                    const targetLook = new BABYLON.Vector3(nextPt.pos.x, 1.2, nextPt.pos.z);
                    cinematicTravelTo(pt.pos, targetLook, 5000); 
                    
                    setTimeout(() => {
                        if(!isTouring) return;
                        const currentTarget = walkCam.getTarget().clone();
                        const leftTarget = currentTarget.add(new BABYLON.Vector3(-3, -0.5, 3)); 
                        cinematicTravelTo(walkCam.position, leftTarget, 2500);
                        
                        setTimeout(() => {
                            if(!isTouring) return;
                            const rightTarget = currentTarget.add(new BABYLON.Vector3(3, -0.5, 3)); 
                            cinematicTravelTo(walkCam.position, rightTarget, 2500);
                            setTimeout(() => { idx = nextIdx; playNextLeg(); }, 3000);
                        }, 2800);
                    }, 5200); 
                }
                playNextLeg();
            }
        };

        window.submitLead = function(){ localStorage.setItem("sandmotion_unlocked", "true"); document.getElementById("lead-modal").style.display="none"; window.setMode('walk'); };
        window.closeModal = function(){ document.getElementById("lead-modal").style.display="none"; };
        window.takeScreenshot = function(){ BABYLON.Tools.CreateScreenshot(engine, sceneRef.activeCamera, {precision:2}, (d)=> { const l=document.createElement('a'); l.href=d; l.download='p.png'; l.click(); }) };

        function createTeleportPuck(pos, look){ 
            const hit = BABYLON.MeshBuilder.CreateDisc("hit", {radius: 0.6}, sceneRef);
            hit.rotation.x = Math.PI/2; hit.position = pos; hit.position.y = 0.05; hit.visibility = 0;

            const core = BABYLON.MeshBuilder.CreateDisc("core", {radius: 0.1, tessellation: 32}, sceneRef);
            core.rotation.x = Math.PI/2; core.position = pos; core.position.y = 0.03;
            const coreMat = new BABYLON.StandardMaterial("coreMat", sceneRef);
            coreMat.emissiveColor = new BABYLON.Color3(0, 1, 1); 
            coreMat.disableLighting = true;
            core.material = coreMat;

            const pulse = BABYLON.MeshBuilder.CreateDisc("pulse", {radius: 0.4, tessellation: 64}, sceneRef);
            pulse.rotation.x = Math.PI/2; pulse.position = pos; pulse.position.y = 0.02;
            const pulseMat = new BABYLON.StandardMaterial("pulseMat", sceneRef);
            pulseMat.emissiveColor = new BABYLON.Color3(0, 0.9, 1); 
            pulseMat.alpha = 0.6;
            pulseMat.disableLighting = true;
            pulse.material = pulseMat;

            const alphaAnim = new BABYLON.Animation("a", "material.alpha", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            alphaAnim.setKeys([{frame: 0, value: 0.6}, {frame: 60, value: 0.0}]);
            
            const scaleAnim = new BABYLON.Animation("s", "scaling", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            scaleAnim.setKeys([{frame: 0, value: new BABYLON.Vector3(0.5, 0.5, 0.5)}, {frame: 60, value: new BABYLON.Vector3(1.5, 1.5, 1.5)}]);

            pulse.animations.push(alphaAnim);
            pulse.animations.push(scaleAnim);
            sceneRef.beginAnimation(pulse, 0, 60, true);

            hit.actionManager = new BABYLON.ActionManager(sceneRef);
            hit.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, function(){
                if(currentMode!=='walk') window.setMode('walk');
                stopTour();
                cinematicTravelTo(pos, walkCam.position.add(BABYLON.Vector3.Forward().scale(5)), 1500);
            }));
            
            navPucks.push(core); navPucks.push(pulse); navPucks.push(hit);
        }

        function createRoomLabel(node) {
            const absPos = node.getAbsolutePosition();
            const rect = new BABYLON.GUI.Rectangle(); 
            rect.width = "260px"; rect.height = "80px"; rect.cornerRadius = 14;
            rect.color = "transparent"; rect.background = "rgba(0,0,0,0.85)"; rect.zIndex = 10;
            const stack = new BABYLON.GUI.StackPanel(); stack.isVertical = true; rect.addControl(stack);
            
            const name = node.name.split("_")[1] || "Room";
            const text = new BABYLON.GUI.TextBlock(); text.text = name.toUpperCase(); text.color = "white"; text.fontWeight = "900"; text.fontSize = 24; text.height = "40px"; text.fontFamily = "Montserrat"; stack.addControl(text);
            
            const dimText = (node.name.split("_")[2] || "").replace("ft","'");
            const dim = new BABYLON.GUI.TextBlock(); dim.text = dimText; dim.color = "#d0d0d0"; dim.fontSize = 16; dim.height = "25px"; dim.fontFamily = "Montserrat"; stack.addControl(dim);
            
            const dummy = new BABYLON.TransformNode("lbl_" + node.name); 
            dummy.position = absPos;
            advancedTexture.addControl(rect); rect.linkWithMesh(dummy); rect.linkOffsetY = -30;
            
            if(window.innerWidth < 768) { rect.scaleX = 0.65; rect.scaleY = 0.65; } 
            else { rect.scaleX = 1.1; rect.scaleY = 1.1; }
            labels.push(rect); rect.isVisible = false; 
        };

        function createInfoSpot(pos, name){ /*...*/ }
        function cinematicTravelTo(dest, look, duration) {
            isMoving = true; moveStartTime = Date.now(); moveDuration = duration;
            walkCam.applyGravity = false; walkCam.checkCollisions = false;
            startPos = walkCam.position.clone(); targetPos = new BABYLON.Vector3(dest.x, 1.2, dest.z);
            startTarget = walkCam.getTarget().clone(); endTarget = look.clone();
        }

        // --- FIXED SUN ROTATION LOGIC ---
        const slider = document.getElementById("time-slider");
        if(slider) {
            slider.addEventListener("input", function() {
                const val = this.value; 
                // Rotates the entire reflection map
                const angle = ((val / 100) * Math.PI * 2); 
                
                if(scene.environmentTexture) {
                    scene.environmentTexture.rotationY = angle;
                }

                if(sunLight) {
                    // Sync shadow light with IBL rotation
                    sunLight.direction.x = Math.cos(angle); 
                    sunLight.direction.z = Math.sin(angle);
                    if(!blueprintMode) sunLight.intensity = 1.2;
                }
            });
        }

        const scene = createScene();
        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => { engine.resize(); if(blueprintMode) updateOrtho(); });
    });
    </script>
</body>
</html>